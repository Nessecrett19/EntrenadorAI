<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Agente A-Frame con Aprendizaje</title>
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
</head>
<body>
  <a-scene background="color: #a5faff">
    <!-- Agente -->
    <a-entity id="agent" position="0 0.160 -3" scale="0.01 0.01 0.01" gltf-model="tour_ia.glb"></a-entity>

    <!-- Meta (un cubo amarillo) -->
    <a-box id="goal" position="4 0.1 4" color="yellow" depth="0.2" height="0.2" width="0.2"></a-box>

    <!-- Obst√°culos (agregados manualmente) -->
    <a-box position="1 0.1 2" color="red" depth="1" height="1" width="1"></a-box>
    <a-box position="3 0.1 -1" color="blue" depth="1" height="1" width="1"></a-box>
    <a-box position="-2 0.1 -2" color="green" depth="1" height="1" width="1"></a-box>

    <!-- Habitaci√≥n y objetos -->
    <a-entity id="casa" position="0 0.169 -3" scale="9 9 9" gltf-model="habitacion1.glb"></a-entity>
    <a-entity position="-0.63348 -15.64467 20.2487" scale="100 100 100" gltf-model="Librero.glb"></a-entity>
    <a-entity position="16.87996 -5.87886 -1.26722" scale="0.08 0.089 0.099" gltf-model="escritorio biblioteca.glb"></a-entity>
    <a-entity position="10.05495 -16.03651 -1.17274" scale="10 10 10" gltf-model="silla biblioteca.glb" rotation="0 270 0"></a-entity>

    <!-- C√°mara -->
    <a-camera position="0 1.6 5"></a-camera>
  </a-scene>

  <script>
    const model = tf.sequential();
    model.add(tf.layers.dense({ units: 16, activation: 'relu', inputShape: [6] }));  // 4 distancias + 2 coordenadas (X, Z)
    model.add(tf.layers.dense({ units: 3, activation: 'softmax' })); // izquierda, derecha, adelante

    model.compile({
      optimizer: tf.train.adam(0.01),
      loss: 'categoricalCrossentropy'
    });

    async function loadModel() {
      try {
        const loaded = await tf.loadLayersModel('indexeddb://agente-modelo');
        model.setWeights(loaded.getWeights());
        console.log('üì¶ Modelo cargado desde IndexedDB');
      } catch (e) {
        console.log('‚ö†Ô∏è No se encontr√≥ modelo previo, iniciando nuevo');
      }
    }

    loadModel();

    // Guardar el modelo autom√°ticamente cada 30s
    setInterval(() => {
      model.save('indexeddb://agente-modelo');
      console.log('‚úÖ Modelo guardado');
    }, 30000);

    function getAgentPosition() {
      return document.getElementById('agent').object3D.position;
    }

    function getGoalPosition() {
      return document.getElementById('goal').object3D.position;
    }

    // Calcular la distancia entre el agente y la meta
    function getDistanceToGoal() {
      const agentPos = getAgentPosition();
      const goalPos = getGoalPosition();
      return Math.sqrt(
        Math.pow(agentPos.x - goalPos.x, 2) +
        Math.pow(agentPos.z - goalPos.z, 2)
      );
    }

    // Funci√≥n que calcula las distancias a los obst√°culos
    function getObstacleDistances() {
      const obstacles = document.querySelectorAll('a-box');
      const agentPos = getAgentPosition();

      let distances = [];
      obstacles.forEach((obstacle) => {
        const obstaclePos = obstacle.object3D.position;
        const distance = Math.sqrt(
          Math.pow(agentPos.x - obstaclePos.x, 2) +
          Math.pow(agentPos.z - obstaclePos.z, 2)
        );
        distances.push(distance);
      });

      // Si no hay obst√°culos, devolver valores muy grandes
      if (distances.length === 0) {
        distances = [100, 100, 100];
      }

      return distances;
    }

    // Funci√≥n para generar el estado (entradas del modelo)
    function getState() {
      const agent = getAgentPosition();
      const goal = getGoalPosition();
      const dx = goal.x - agent.x;
      const dz = goal.z - agent.z;
      const distToGoal = getDistanceToGoal();

      const obstacleDistances = getObstacleDistances();
      return [...obstacleDistances, dx, dz];  // 3 distancias de obst√°culos + 2 distancias a la meta
    }

    function calculateReward(distBefore, distAfter) {
      return distAfter < distBefore ? 1 : -1;  // Recompensa basada en la proximidad a la meta
    }

    async function getAction(state) {
      const input = tf.tensor2d([state]);
      const output = model.predict(input);
      const action = output.argMax(1).dataSync()[0];
      return action;
    }

    async function trainModel(state, action, reward) {
      const input = tf.tensor2d([state]);
      const target = tf.tensor2d([[0, 0, 0]]);
      target.arraySync()[0][action] = reward;  // Actualizar la acci√≥n espec√≠fica
      await model.fit(input, target, { epochs: 1 });
    }

    function applyAction(action) {
      const agent = document.getElementById('agent');
      const pos = agent.getAttribute('position');
      const step = 0.2;

      if (action === 0) pos.x -= step;      // izquierda
      if (action === 1) pos.x += step;      // derecha
      if (action === 2) pos.z -= step;      // adelante

      agent.setAttribute('position', pos);
    }

    async function trainStep() {
      const state = getState();
      const distBefore = getDistanceToGoal();
      const action = await getAction(state);
      applyAction(action);
      const distAfter = getDistanceToGoal();
      const reward = calculateReward(distBefore, distAfter);
      await trainModel(state, action, reward);
    }

    setInterval(trainStep, 200);
  </script>
</body>
</html>
